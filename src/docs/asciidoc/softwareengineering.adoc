[#sw-engineering]
== Software Engineering

=== Definition

The term encompasses a specific set of disciplines including defined process, inspections and walkthroughs, requirements engineering, traceability matrices, metrics, precise quality control, rigorous planning and tracking, and coding and documentation standards. 

In general, software engineering focuses more on techniques for the application of software development in industry, while computer science focuses more on algorithms and theory.

=== Methodologies

Many efforts have been made to press Software Engineering (SE) in a set of rules in order to be as efficient as possible. In the last years the https://en.wikipedia.org/wiki/Scrum_\(software_development\[SCRUM]) approach has reached broad adoption in the industry.

To give you an idea that many bright people have tried very hard to pinpoint a perfect approach to software development, here is a small list of SE Methodologies:

 - Agile Unified Process (AUP)
 - Dynamic systems development method (DSDM)
 - Constructionist design methodology (CDM)
 - Extreme programming (XP)
 - Iterative and incremental development
 - Kanban
 - Lean software development
 - Open Unified Process
 - Pair programming
 - Rapid application development (RAD)
 - Rational Unified Process (RUP)
 - Structured systems analysis and design method (SSADM)
 - Unified Process (UP)

This list is not comprehensive, for example the Waterfall approach is not mentioned. For the purposes of this book, we'll just mention that there are many processes and approaches to develop software, and maybe the next one is invented in the very near future.

There are also voices who question the process and approaches as a whole. 'Self organizing teams' and 'Agile development' may be mentioned in this respect.

=== Challenges

Working as a software developer not only means to master technically challenging details, but also and foremost to communicate clearly and efficiently with your coworkers. 

Developing software and get paid for it implies to work together in a team, with people which have different mind- and skillsets, different backgrounds and also different motivations, all of which contribute in their specific way to the success or failure of a software project.

This is a demanding challenge by its own, not to speak of always changing environments and tool sets which have to be relearned continuously.

If you do sofware development for a living, you will only be successful if you prove to be a 'life long' learner. You don't have any other option.

Creating software means experimenting, programming means learning on the go. One major difference between software projects and building houses or bridges for example is that you rarely, if never, encounter a software project whose requirements match with one already done in the past.

Naturally, the probability of failure decreases if similar projects are done over and over again. On the other hand you have to consider that doing the same thing over and over again does not really pay well, since it can be automated, and this can and will be done by your competitors. 

The definition of a successful software project is not as easy as it would seem - it is common that the requirements change over time, the whole focus of a project can change since all participants learn during the process of development.

Software projects are very expensive, since they are hugely dependent on human, manual work. Some parts can be automated, typically only trivial tasks. The industry awaits eagerly a break through in artificial intelligence which makes currently unthinkable automation possible - but as things are today this is still just science fiction.

Current state of the art is just that a software project always means to apply known approaches and technologies to new problems, and whilst doing this new ideas come up, new ways of solving problems are just invented on the go. 
 
On the other hand it is also very common that software projects fail and don't reach their initial goal. In no other industry it is as common as in the software industry that there are delays in the delivery of the software artefacts. 

Either way, it is very hard to predict - if not impossible - how things will develop in a software project.

Some say this is due to the fact that software engineering still lacks in defined formalisms for developing the artefacts which a customer pays for. 

Unlike other engineering fields like in the construction industry there are no or only very few rules which always apply. A counterexample would be the field of mathematics - in a purely mathematical domain it is very easy to measure a failure or a success, since it can be exactly pinpointed. In the domain of software development, this is not as easy.
 
 Software engineering is also a very young discipline, compared which other engineering disciplines which have a long history. Those cited fields of work all had their problems establishing a common ground, a common set of rules which make the difference between a working approach and a failed experiment. 

The software industry still has to learn as a whole to get to such common established rules. But in the short history of Software Engineering - the term was first phrased on a conference some 40 years ago - projects were finished successfully even without such rules, others failed miserably but were very well planned and documented, but created the wrong assets.

https://www.computer.org/cms/Computer.org/ComputingNow/homepage/2009/0709/rW_SO_Viewpoints.pdf[Tom DeMarco], a well known vocal advocate of software engineering, said almost ten years ago that his conclusion of working on software teams for most of his life was that software should be developed incrementally.

This means that whilst working towards a greater goal, one should make sure that additional features are added to the existing project, such that a client would profit from them right away.

The more important goal is transformation, creating software that changes the world or that transforms a company or how it does business.

There is also a saying by Confucius which is used fairly often: 'A journey of a thousand miles begins with a single step.'. This maps nicely to the way software is developed.

Those viewpoints cited above just underline that software engineering is a complicated domain and it takes years of practice to really be a proficient software developer.

